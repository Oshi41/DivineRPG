package divinerpg.objects.entities.entity.vanilla.dragon;

import divinerpg.DivineRPG;
import divinerpg.config.Config;
import divinerpg.objects.entities.entity.vanilla.dragon.phase.base.IPhase;
import divinerpg.objects.entities.entity.vanilla.dragon.phase.base.IPhaseChange;
import net.minecraft.block.Block;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.*;
import net.minecraft.entity.ai.EntityAIBase;
import net.minecraft.entity.ai.EntityAIFindEntityNearest;
import net.minecraft.entity.ai.EntityAIFindEntityNearestPlayer;
import net.minecraft.entity.ai.EntityAINearestAttackableTarget;
import net.minecraft.entity.boss.dragon.phase.PhaseList;
import net.minecraft.entity.monster.EntityMob;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.entity.projectile.EntityDragonFireball;
import net.minecraft.init.Blocks;
import net.minecraft.init.SoundEvents;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.network.datasync.DataParameter;
import net.minecraft.network.datasync.DataSerializers;
import net.minecraft.network.datasync.EntityDataManager;
import net.minecraft.pathfinding.Path;
import net.minecraft.pathfinding.PathHeap;
import net.minecraft.pathfinding.PathPoint;
import net.minecraft.util.DamageSource;
import net.minecraft.util.EnumParticleTypes;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BossInfo;
import net.minecraft.world.BossInfoServer;
import net.minecraft.world.World;
import net.minecraft.world.gen.feature.WorldGenEndPodium;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.logging.log4j.Logger;
import thaumcraft.common.entities.ai.pech.AINearestAttackableTargetPech;

import javax.annotation.Nullable;
import java.util.*;
import java.util.stream.Collectors;

public abstract class DivineDragonBase extends EntityMob implements IEntityMultiPart, IPhaseChange, IRangedAttackMob {
    public static final DataParameter<String> PHASE = EntityDataManager.createKey(DivineDragonBase.class, DataSerializers.STRING);
    public static final DataParameter<BlockPos> GUARD_POSITION = EntityDataManager.createKey(DivineDragonBase.class, DataSerializers.BLOCK_POS);

    private BossInfoServer bossInfo = new BossInfoServer(this.getDisplayName(), this.getBarColor(), BossInfo.Overlay.PROGRESS);

    /**
     * A series of points describing three circles. The first is low to the ground and described by the first 12 points;
     * the next 8 points describe a spiral upwards to the next, tighter circle of just 4 points. Generated by
     * initPathPoints.
     */
    private final PathPoint[] pathPoints = new PathPoint[24];
    /**
     * An array of bitmaps indicating, for each member of pathPoints, which other members should be considered
     * "neighboring" for the purpose of path-finding. The set bits indicate the indexes into pathPoints that should be
     * considered to be candidates for the next step in a path through the circles. Generated by initPathPoints.
     */
    private final int[] neighbors = new int[24];
    private final PathHeap pathFindQueue = new PathHeap();
    private final Logger LOGGER;
    private DivinePhaseManager phaseManager;
    /**
     * Ring buffer array for the last 64 Y-positions and yaw rotations. Used to calculate offsets for the animations.
     */
    public double[][] ringBuffer = new double[64][3];
    /**
     * Index into the ring buffer. Incremented once per tick and restarts at 0 once it reaches the end of the buffer.
     */
    public int ringBufferIndex = -1;
    /**
     * The head bounding box of a dragon
     */
    public final List<MultiPartEntityPart> heads = new ArrayList<>();
    public MultiPartEntityPart dragonPartNeck = new MultiPartEntityPart(this, "neck", 6.0F, 6.0F);
    /**
     * The body bounding box of a dragon
     */
    public MultiPartEntityPart dragonPartBody = new MultiPartEntityPart(this, "body", 8.0F, 8.0F);
    public MultiPartEntityPart dragonPartTail1 = new MultiPartEntityPart(this, "tail", 4.0F, 4.0F);
    public MultiPartEntityPart dragonPartTail2 = new MultiPartEntityPart(this, "tail", 4.0F, 4.0F);
    public MultiPartEntityPart dragonPartTail3 = new MultiPartEntityPart(this, "tail", 4.0F, 4.0F);
    public MultiPartEntityPart dragonPartWing1 = new MultiPartEntityPart(this, "wing", 4.0F, 4.0F);
    public MultiPartEntityPart dragonPartWing2 = new MultiPartEntityPart(this, "wing", 4.0F, 4.0F);

    /**
     * Amount of damage received while sitting phase
     */
    protected int sittingDamageReceived;
    public float animTime;
    public float prevAnimTime;
    public int growlTime = 200;
    /**
     * Activated if the dragon is flying though obsidian, white stone or bedrock. Slows movement and animation speed.
     */
    public boolean slowed;

    /**
     * Can dragon break blocks
     */
    public boolean canBreakBlocks = false;

    /**
     * Max flame tick time
     */
    public int flameTicks = 200;

    /**
     * Power of dragon knokback
     */
    public float knockback = 1;

    public int deathTicks;

    private List<EntityAIBase> targetAI;

    protected DivineDragonBase(World worldIn) {
        super(worldIn);
        this.setSize(16.0F, 8.0F);
        this.noClip = true;
        this.isImmuneToFire = true;
        this.growlTime = 100;
        this.ignoreFrustumCheck = true;
        LOGGER = DivineRPG.logger;
        phaseManager = createManager();
        this.heads.add(new MultiPartEntityPart(this, "head", 6.0F, 6.0F));
    }

    /**
     * Returns point on map dragon will defends
     *
     * @return
     */
    public BlockPos getDragonGuardCenter() {
        return getDataManager().get(GUARD_POSITION);
    }

    /**
     * Returns position of healing constuction
     *
     * @return
     */
    public abstract BlockPos getHealingPosition();

    @Override
    protected void applyEntityAttributes() {
        super.applyEntityAttributes();
        Config.initEntityAttributes(this);

        getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(10);
        getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(80);
    }

    @Override
    protected void entityInit() {
        super.entityInit();

        getDataManager().register(PHASE, PhaseRegistry.HOVER.toString());
        getDataManager().register(GUARD_POSITION, BlockPos.ORIGIN);
    }

    @Override
    protected void initEntityAI() {
        super.initEntityAI();

        targetAI = new ArrayList<>();
        targetAI.add(new EntityAINearestAttackableTarget<>(this, EntityPlayer.class, true));
        targetAI.add(new EntityAINearestAttackableTarget<>(this, EntityMob.class, true));
    }

    /**
     * Creating default phase manager
     *
     * @return
     */
    protected DivinePhaseManager createManager() {
        return new DivinePhaseManager(this, this);
    }

    /**
     * Override this to change behavior
     *
     * @param dragon   - dragon entity
     * @param current  - current phase
     * @param toChange - change that will be set
     * @return
     */
    @Override
    public ResourceLocation fixPhase(DivineDragonBase dragon, IPhase current, ResourceLocation toChange) {
        return toChange;
    }

    @Override
    public void notifyDataManagerChange(DataParameter<?> key) {
        if (PHASE.equals(key) && world.isRemote) {
            getPhaseManager().setPhase(new ResourceLocation(getDataManager().get(PHASE)));
        }

        super.notifyDataManagerChange(key);
    }

    /**
     * Gets current phase manager
     *
     * @return
     */
    public DivinePhaseManager getPhaseManager() {
        return phaseManager;
    }

    /**
     * Find and return a path among the circles described by pathPoints, or null if the shortest path would just be
     * directly between the start and finish with no intermediate points.
     * <p>
     * Starting with pathPoint[startIdx], it searches the neighboring points (and their neighboring points, and so on)
     * until it reaches pathPoint[finishIdx], at which point it calls makePath to seal the deal.
     */
    @Nullable
    public Path findPath(int startIdx, int finishIdx, @Nullable PathPoint andThen) {
        for (int i = 0; i < 24; ++i) {
            PathPoint pathpoint = this.pathPoints[i];
            pathpoint.visited = false;
            pathpoint.distanceToTarget = 0.0F;
            pathpoint.totalPathDistance = 0.0F;
            pathpoint.distanceToNext = 0.0F;
            pathpoint.previous = null;
            pathpoint.index = -1;
        }

        PathPoint pathpoint4 = this.pathPoints[startIdx];
        PathPoint pathpoint5 = this.pathPoints[finishIdx];
        pathpoint4.totalPathDistance = 0.0F;
        pathpoint4.distanceToNext = pathpoint4.distanceTo(pathpoint5);
        pathpoint4.distanceToTarget = pathpoint4.distanceToNext;
        this.pathFindQueue.clearPath();
        this.pathFindQueue.addPoint(pathpoint4);
        PathPoint pathpoint1 = pathpoint4;
        int j = 12;

        while (!this.pathFindQueue.isPathEmpty()) {
            PathPoint pathpoint2 = this.pathFindQueue.dequeue();

            if (pathpoint2.equals(pathpoint5)) {
                if (andThen != null) {
                    andThen.previous = pathpoint5;
                    pathpoint5 = andThen;
                }

                return this.makePath(pathpoint4, pathpoint5);
            }

            if (pathpoint2.distanceTo(pathpoint5) < pathpoint1.distanceTo(pathpoint5)) {
                pathpoint1 = pathpoint2;
            }

            pathpoint2.visited = true;
            int k = 0;

            for (int l = 0; l < 24; ++l) {
                if (this.pathPoints[l] == pathpoint2) {
                    k = l;
                    break;
                }
            }

            for (int i1 = j; i1 < 24; ++i1) {
                if ((this.neighbors[k] & 1 << i1) > 0) {
                    PathPoint pathpoint3 = this.pathPoints[i1];

                    if (!pathpoint3.visited) {
                        float f = pathpoint2.totalPathDistance + pathpoint2.distanceTo(pathpoint3);

                        if (!pathpoint3.isAssigned() || f < pathpoint3.totalPathDistance) {
                            pathpoint3.previous = pathpoint2;
                            pathpoint3.totalPathDistance = f;
                            pathpoint3.distanceToNext = pathpoint3.distanceTo(pathpoint5);

                            if (pathpoint3.isAssigned()) {
                                this.pathFindQueue.changeDistance(pathpoint3, pathpoint3.totalPathDistance + pathpoint3.distanceToNext);
                            } else {
                                pathpoint3.distanceToTarget = pathpoint3.totalPathDistance + pathpoint3.distanceToNext;
                                this.pathFindQueue.addPoint(pathpoint3);
                            }
                        }
                    }
                }
            }
        }

        if (pathpoint1 == pathpoint4) {
            return null;
        } else {
            LOGGER.debug("Failed to find path from {} to {}", Integer.valueOf(startIdx), Integer.valueOf(finishIdx));

            if (andThen != null) {
                andThen.previous = pathpoint1;
                pathpoint1 = andThen;
            }

            return this.makePath(pathpoint4, pathpoint1);
        }
    }

    /**
     * Generates values for the fields pathPoints, and neighbors, and then returns the nearest pathPoint to the
     * specified position.
     */
    public int initPathPoints() {
        double distance = getEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).getAttributeValue();

        if (this.pathPoints[0] == null) {
            for (int i = 0; i < 24; ++i) {
                int j = 5;
                int x;
                int z;

                if (i < 12) {
                    x = (int) (posX + distance * MathHelper.cos(2.0F * (-(float) Math.PI + 0.2617994F * (float) i)));
                    z = (int) (posZ + distance * MathHelper.sin(2.0F * (-(float) Math.PI + 0.2617994F * (float) i)));
                } else if (i < 20) {
                    int lvt_3_1_ = i - 12;
                    x = (int) (posX + distance * 0.6 * MathHelper.cos(2.0F * (-(float) Math.PI + 0.3926991F * (float) lvt_3_1_)));
                    z = (int) (posZ + distance * 0.6 * MathHelper.sin(2.0F * (-(float) Math.PI + 0.3926991F * (float) lvt_3_1_)));
                    j += 10;
                } else {
                    int k1 = i - 20;
                    x = (int) (posX + distance * 0.3 * MathHelper.cos(2.0F * (-(float) Math.PI + ((float) Math.PI / 4F) * (float) k1)));
                    z = (int) (posZ + distance * 0.3 * MathHelper.sin(2.0F * (-(float) Math.PI + ((float) Math.PI / 4F) * (float) k1)));
                }

                int y = Math.max(this.world.getSeaLevel() + 10, this.world.getTopSolidOrLiquidBlock(new BlockPos(x, 0, z)).getY() + j);
                this.pathPoints[i] = new PathPoint(x, y, z);
            }

            this.neighbors[0] = 6146;
            this.neighbors[1] = 8197;
            this.neighbors[2] = 8202;
            this.neighbors[3] = 16404;
            this.neighbors[4] = 32808;
            this.neighbors[5] = 32848;
            this.neighbors[6] = 65696;
            this.neighbors[7] = 131392;
            this.neighbors[8] = 131712;
            this.neighbors[9] = 263424;
            this.neighbors[10] = 526848;
            this.neighbors[11] = 525313;
            this.neighbors[12] = 1581057;
            this.neighbors[13] = 3166214;
            this.neighbors[14] = 2138120;
            this.neighbors[15] = 6373424;
            this.neighbors[16] = 4358208;
            this.neighbors[17] = 12910976;
            this.neighbors[18] = 9044480;
            this.neighbors[19] = 9706496;
            this.neighbors[20] = 15216640;
            this.neighbors[21] = 13688832;
            this.neighbors[22] = 11763712;
            this.neighbors[23] = 8257536;
        }

        return this.getNearestPpIdx(this.posX, this.posY, this.posZ);
    }

    /**
     * Returns the index into pathPoints of the nearest PathPoint.
     */
    public int getNearestPpIdx(double x, double y, double z) {
        float f = 10000.0F;
        int i = 0;
        PathPoint pathpoint = new PathPoint(MathHelper.floor(x), MathHelper.floor(y), MathHelper.floor(z));
        int j = 12;

        for (int k = j; k < 24; ++k) {
            if (this.pathPoints[k] != null) {
                float f1 = this.pathPoints[k].distanceToSquared(pathpoint);

                if (f1 < f) {
                    f = f1;
                    i = k;
                }
            }
        }

        return i;
    }

    /**
     * Create and return a new PathEntity defining a path from the start to the finish, using the connections already
     * made by the caller, findPath.
     */
    private Path makePath(PathPoint start, PathPoint finish) {
        int i = 1;

        for (PathPoint pathpoint = finish; pathpoint.previous != null; pathpoint = pathpoint.previous) {
            ++i;
        }

        PathPoint[] apathpoint = new PathPoint[i];
        PathPoint pathpoint1 = finish;
        --i;

        for (apathpoint[i] = finish; pathpoint1.previous != null; apathpoint[i] = pathpoint1) {
            pathpoint1 = pathpoint1.previous;
            --i;
        }

        return new Path(apathpoint);
    }

    @Override
    public World getWorld() {
        return world;
    }

    @Override
    public boolean attackEntityFromPart(MultiPartEntityPart dragonPart, DamageSource source, float damage) {
        damage = getPhaseManager().getCurrentPhase().getAdjustedDamage(dragonPart, source, damage);

        if (!heads.contains(dragonPart)) {
            damage = damage / 4.0F + Math.min(damage, 1.0F);
        }

        if (damage < 0.01F) {
            return false;
        } else {
            if (source.getTrueSource() instanceof EntityPlayer || source.isExplosion()) {
                float f = this.getHealth();
                this.attackEntityFrom(source, damage);

                if (this.getHealth() <= 0.0F && !getPhaseManager().getCurrentPhase().getIsStationary()) {
                    this.setHealth(1.0F);
                    getPhaseManager().setPhase(PhaseRegistry.DYING);
                }

                if (getPhaseManager().getCurrentPhase().getIsStationary()) {
                    this.sittingDamageReceived = (int) ((float) this.sittingDamageReceived + (f - this.getHealth()));

                    if ((float) this.sittingDamageReceived > 0.25F * this.getMaxHealth()) {
                        this.sittingDamageReceived = 0;
                        getPhaseManager().setPhase(PhaseRegistry.TAKEOFF);
                    }
                }
            }

            return true;
        }
    }

    /**
     * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
     * use this to react to sunlight and start to burn.
     */
    public void onLivingUpdate() {
        if (targetAI != null) {
            targetAI.stream().filter(EntityAIBase::shouldExecute).findFirst().ifPresent(EntityAIBase::startExecuting);
        }

        if (this.world.isRemote) {
            this.setHealth(this.getHealth());

            if (!this.isSilent()) {
                float f = MathHelper.cos(this.animTime * ((float) Math.PI * 2F));
                float f1 = MathHelper.cos(this.prevAnimTime * ((float) Math.PI * 2F));

                if (f1 <= -0.3F && f >= -0.3F) {
                    this.world.playSound(this.posX, this.posY, this.posZ, SoundEvents.ENTITY_ENDERDRAGON_FLAP, this.getSoundCategory(), 5.0F, 0.8F + this.rand.nextFloat() * 0.3F, false);
                }

                if (!getPhaseManager().getCurrentPhase().getIsStationary() && --this.growlTime < 0) {
                    this.world.playSound(this.posX, this.posY, this.posZ, SoundEvents.ENTITY_ENDERDRAGON_GROWL, this.getSoundCategory(), 2.5F, 0.8F + this.rand.nextFloat() * 0.3F, false);
                    this.growlTime = 200 + this.rand.nextInt(200);
                }
            }
        }

        this.prevAnimTime = this.animTime;

        if (this.getHealth() <= 0.0F) {
            float f12 = (this.rand.nextFloat() - 0.5F) * 8.0F;
            float f13 = (this.rand.nextFloat() - 0.5F) * 4.0F;
            float f15 = (this.rand.nextFloat() - 0.5F) * 8.0F;
            this.world.spawnParticle(EnumParticleTypes.EXPLOSION_LARGE, this.posX + (double) f12, this.posY + 2.0D + (double) f13, this.posZ + (double) f15, 0.0D, 0.0D, 0.0D);
        } else {
            float f11 = 0.2F / (MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ) * 10.0F + 1.0F);
            f11 = f11 * (float) Math.pow(2.0D, this.motionY);

            if (getPhaseManager().getCurrentPhase().getIsStationary()) {
                this.animTime += 0.1F;
            } else if (this.slowed) {
                this.animTime += f11 * 0.5F;
            } else {
                this.animTime += f11;
            }

            this.rotationYaw = MathHelper.wrapDegrees(this.rotationYaw);

            if (this.isAIDisabled()) {
                this.animTime = 0.5F;
            } else {
                if (this.ringBufferIndex < 0) {
                    for (int i = 0; i < this.ringBuffer.length; ++i) {
                        this.ringBuffer[i][0] = this.rotationYaw;
                        this.ringBuffer[i][1] = this.posY;
                    }
                }

                if (++this.ringBufferIndex == this.ringBuffer.length) {
                    this.ringBufferIndex = 0;
                }

                this.ringBuffer[this.ringBufferIndex][0] = this.rotationYaw;
                this.ringBuffer[this.ringBufferIndex][1] = this.posY;

                if (this.world.isRemote) {
                    if (this.newPosRotationIncrements > 0) {
                        double d5 = this.posX + (this.interpTargetX - this.posX) / (double) this.newPosRotationIncrements;
                        double d0 = this.posY + (this.interpTargetY - this.posY) / (double) this.newPosRotationIncrements;
                        double d1 = this.posZ + (this.interpTargetZ - this.posZ) / (double) this.newPosRotationIncrements;
                        double d2 = MathHelper.wrapDegrees(this.interpTargetYaw - (double) this.rotationYaw);
                        this.rotationYaw = (float) ((double) this.rotationYaw + d2 / (double) this.newPosRotationIncrements);
                        this.rotationPitch = (float) ((double) this.rotationPitch + (this.interpTargetPitch - (double) this.rotationPitch) / (double) this.newPosRotationIncrements);
                        --this.newPosRotationIncrements;
                        this.setPosition(d5, d0, d1);
                        this.setRotation(this.rotationYaw, this.rotationPitch);
                    }

                    getPhaseManager().getCurrentPhase().doClientRenderEffects();
                } else {
                    IPhase iphase = getPhaseManager().getCurrentPhase();
                    iphase.doLocalUpdate();

                    if (getPhaseManager().getCurrentPhase() != iphase) {
                        iphase = getPhaseManager().getCurrentPhase();
                        iphase.doLocalUpdate();
                    }

                    Vec3d vec3d = iphase.getTargetLocation();

                    if (vec3d != null) {
                        double d6 = vec3d.x - this.posX;
                        double d7 = vec3d.y - this.posY;
                        double d8 = vec3d.z - this.posZ;
                        double d3 = d6 * d6 + d7 * d7 + d8 * d8;
                        float f5 = iphase.getMaxRiseOrFall();
                        d7 = MathHelper.clamp(d7 / (double) MathHelper.sqrt(d6 * d6 + d8 * d8), -f5, f5);
                        this.motionY += d7 * 0.10000000149011612D;
                        this.rotationYaw = MathHelper.wrapDegrees(this.rotationYaw);
                        double d4 = MathHelper.clamp(MathHelper.wrapDegrees(180.0D - MathHelper.atan2(d6, d8) * (180D / Math.PI) - (double) this.rotationYaw), -50.0D, 50.0D);
                        Vec3d vec3d1 = (new Vec3d(vec3d.x - this.posX, vec3d.y - this.posY, vec3d.z - this.posZ)).normalize();
                        Vec3d vec3d2 = (new Vec3d(MathHelper.sin(this.rotationYaw * 0.017453292F), this.motionY, -MathHelper.cos(this.rotationYaw * 0.017453292F))).normalize();
                        float f7 = Math.max(((float) vec3d2.dotProduct(vec3d1) + 0.5F) / 1.5F, 0.0F);
                        this.randomYawVelocity *= 0.8F;
                        this.randomYawVelocity = (float) ((double) this.randomYawVelocity + d4 * (double) iphase.getYawFactor());
                        this.rotationYaw += this.randomYawVelocity * 0.1F;
                        float f8 = (float) (2.0D / (d3 + 1.0D));
                        float f9 = 0.06F;
                        this.moveRelative(0.0F, 0.0F, -1.0F, 0.06F * (f7 * f8 + (1.0F - f8)));

                        if (this.slowed) {
                            this.move(MoverType.SELF, this.motionX * 0.800000011920929D, this.motionY * 0.800000011920929D, this.motionZ * 0.800000011920929D);
                        } else {
                            this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
                        }

                        Vec3d vec3d3 = (new Vec3d(this.motionX, this.motionY, this.motionZ)).normalize();
                        float f10 = ((float) vec3d3.dotProduct(vec3d2) + 1.0F) / 2.0F;
                        f10 = 0.8F + 0.15F * f10;
                        this.motionX *= f10;
                        this.motionZ *= f10;
                        this.motionY *= 0.9100000262260437D;
                    }
                }

                heads.forEach(x -> {
                    x.width = 1;
                    x.height = 1;
                });

                this.renderYawOffset = this.rotationYaw;
                this.dragonPartNeck.width = 3.0F;
                this.dragonPartNeck.height = 3.0F;
                this.dragonPartTail1.width = 2.0F;
                this.dragonPartTail1.height = 2.0F;
                this.dragonPartTail2.width = 2.0F;
                this.dragonPartTail2.height = 2.0F;
                this.dragonPartTail3.width = 2.0F;
                this.dragonPartTail3.height = 2.0F;
                this.dragonPartBody.height = 3.0F;
                this.dragonPartBody.width = 5.0F;
                this.dragonPartWing1.height = 2.0F;
                this.dragonPartWing1.width = 4.0F;
                this.dragonPartWing2.height = 3.0F;
                this.dragonPartWing2.width = 4.0F;

                Map<MultiPartEntityPart, Vec3d> avec3d = getAllParts().stream()
                        .collect(Collectors.toMap(x -> x, Entity::getPositionVector));

                float f14 = (float) ((this.getMovementOffsets(5, 1.0F)[1] - this.getMovementOffsets(10, 1.0F)[1]) * 10.0F * 0.017453292F);
                float f16 = MathHelper.cos(f14);
                float f2 = MathHelper.sin(f14);
                float f17 = this.rotationYaw * 0.017453292F;
                float f3 = MathHelper.sin(f17);
                float f18 = MathHelper.cos(f17);
                this.dragonPartBody.onUpdate();
                this.dragonPartBody.setLocationAndAngles(this.posX + (double) (f3 * 0.5F), this.posY, this.posZ - (double) (f18 * 0.5F), 0.0F, 0.0F);
                this.dragonPartWing1.onUpdate();
                this.dragonPartWing1.setLocationAndAngles(this.posX + (double) (f18 * 4.5F), this.posY + 2.0D, this.posZ + (double) (f3 * 4.5F), 0.0F, 0.0F);
                this.dragonPartWing2.onUpdate();
                this.dragonPartWing2.setLocationAndAngles(this.posX - (double) (f18 * 4.5F), this.posY + 2.0D, this.posZ - (double) (f3 * 4.5F), 0.0F, 0.0F);

                if (!this.world.isRemote && this.hurtTime == 0) {
                    this.collideWithEntities(this.world.getEntitiesWithinAABBExcludingEntity(this, this.dragonPartWing1.getEntityBoundingBox().grow(4.0D, 2.0D, 4.0D).offset(0.0D, -2.0D, 0.0D)));
                    this.collideWithEntities(this.world.getEntitiesWithinAABBExcludingEntity(this, this.dragonPartWing2.getEntityBoundingBox().grow(4.0D, 2.0D, 4.0D).offset(0.0D, -2.0D, 0.0D)));
                    heads.forEach(x -> this.attackEntitiesInList(this.world.getEntitiesWithinAABBExcludingEntity(this, x.getEntityBoundingBox().grow(1.0D))));
                    this.attackEntitiesInList(this.world.getEntitiesWithinAABBExcludingEntity(this, this.dragonPartNeck.getEntityBoundingBox().grow(1.0D)));
                }

                double[] adouble = this.getMovementOffsets(5, 1.0F);
                float f19 = MathHelper.sin(this.rotationYaw * 0.017453292F - this.randomYawVelocity * 0.01F);
                float f4 = MathHelper.cos(this.rotationYaw * 0.017453292F - this.randomYawVelocity * 0.01F);
                heads.forEach(Entity::onUpdate);
                this.dragonPartNeck.onUpdate();
                float f20 = this.getHeadYOffset();
                heads.forEach(x -> x.setLocationAndAngles(this.posX + (double) (f19 * 6.5F * f16), this.posY + (double) f20 + (double) (f2 * 6.5F), this.posZ - (double) (f4 * 6.5F * f16), 0.0F, 0.0F));
                this.dragonPartNeck.setLocationAndAngles(this.posX + (double) (f19 * 5.5F * f16), this.posY + (double) f20 + (double) (f2 * 5.5F), this.posZ - (double) (f4 * 5.5F * f16), 0.0F, 0.0F);

                for (int k = 0; k < 3; ++k) {
                    MultiPartEntityPart multipartentitypart = null;

                    if (k == 0) {
                        multipartentitypart = this.dragonPartTail1;
                    }

                    if (k == 1) {
                        multipartentitypart = this.dragonPartTail2;
                    }

                    if (k == 2) {
                        multipartentitypart = this.dragonPartTail3;
                    }

                    double[] adouble1 = this.getMovementOffsets(12 + k * 2, 1.0F);
                    float f21 = this.rotationYaw * 0.017453292F + this.simplifyAngle(adouble1[0] - adouble[0]) * 0.017453292F;
                    float f6 = MathHelper.sin(f21);
                    float f22 = MathHelper.cos(f21);
                    float f23 = 1.5F;
                    float f24 = (float) (k + 1) * 2.0F;
                    multipartentitypart.onUpdate();
                    multipartentitypart.setLocationAndAngles(this.posX - (double) ((f3 * 1.5F + f6 * f24) * f16), this.posY + (adouble1[1] - adouble[1]) - (double) ((f24 + 1.5F) * f2) + 1.5D, this.posZ + (double) ((f18 * 1.5F + f22 * f24) * f16), 0.0F, 0.0F);
                }

                if (!this.world.isRemote) {
                    this.slowed = heads.stream().anyMatch(x -> destroyBlocksInAABB(x.getEntityBoundingBox())) | this.destroyBlocksInAABB(this.dragonPartNeck.getEntityBoundingBox()) | this.destroyBlocksInAABB(this.dragonPartBody.getEntityBoundingBox());
                }

                avec3d.forEach((multiPartEntityPart, vec3d) -> {
                    multiPartEntityPart.prevPosX = vec3d.x;
                    multiPartEntityPart.prevPosY = vec3d.y;
                    multiPartEntityPart.prevPosZ = vec3d.z;
                });
            }
        }

        this.bossInfo.setPercent(this.getHealth() / this.getMaxHealth());
    }

    /**
     * Destroys all blocks that aren't associated with 'The End' inside the given bounding box.
     */
    protected boolean destroyBlocksInAABB(AxisAlignedBB area) {
        if (!canBreakBlocks)
            return false;

        int i = MathHelper.floor(area.minX);
        int j = MathHelper.floor(area.minY);
        int k = MathHelper.floor(area.minZ);
        int l = MathHelper.floor(area.maxX);
        int i1 = MathHelper.floor(area.maxY);
        int j1 = MathHelper.floor(area.maxZ);
        boolean flag = false;
        boolean flag1 = false;

        for (int k1 = i; k1 <= l; ++k1) {
            for (int l1 = j; l1 <= i1; ++l1) {
                for (int i2 = k; i2 <= j1; ++i2) {
                    BlockPos blockpos = new BlockPos(k1, l1, i2);
                    IBlockState iblockstate = this.world.getBlockState(blockpos);
                    Block block = iblockstate.getBlock();

                    if (!block.isAir(iblockstate, this.world, blockpos) && iblockstate.getMaterial() != Material.FIRE) {
                        if (!net.minecraftforge.event.ForgeEventFactory.getMobGriefingEvent(this.world, this)) {
                            flag = true;
                        } else if (block.canEntityDestroy(iblockstate, this.world, blockpos, this) && net.minecraftforge.event.ForgeEventFactory.onEntityDestroyBlock(this, blockpos, iblockstate)) {
                            if (block != Blocks.COMMAND_BLOCK && block != Blocks.REPEATING_COMMAND_BLOCK && block != Blocks.CHAIN_COMMAND_BLOCK && block != Blocks.IRON_BARS && block != Blocks.END_GATEWAY) {
                                flag1 = this.world.setBlockToAir(blockpos) || flag1;
                            } else {
                                flag = true;
                            }
                        } else {
                            flag = true;
                        }
                    }
                }
            }
        }

        if (flag1) {
            double d0 = area.minX + (area.maxX - area.minX) * (double) this.rand.nextFloat();
            double d1 = area.minY + (area.maxY - area.minY) * (double) this.rand.nextFloat();
            double d2 = area.minZ + (area.maxZ - area.minZ) * (double) this.rand.nextFloat();
            this.world.spawnParticle(EnumParticleTypes.EXPLOSION_LARGE, d0, d1, d2, 0.0D, 0.0D, 0.0D);
        }

        return flag;
    }

    /**
     * Returns a double[3] array with movement offsets, used to calculate trailing tail/neck positions. [0] = yaw
     * offset, [1] = y offset, [2] = unused, always 0. Parameters: buffer index offset, partial ticks.
     */
    public double[] getMovementOffsets(int offset, float partialTicks) {
        if (this.getHealth() <= 0.0F) {
            partialTicks = 0.0F;
        }

        partialTicks = 1.0F - partialTicks;
        int i = this.ringBufferIndex - offset & 63;
        int j = this.ringBufferIndex - offset - 1 & 63;
        double[] adouble = new double[3];
        double d0 = this.ringBuffer[i][0];
        double d1 = MathHelper.wrapDegrees(this.ringBuffer[j][0] - d0);
        adouble[0] = d0 + d1 * (double) partialTicks;
        d0 = this.ringBuffer[i][1];
        d1 = this.ringBuffer[j][1] - d0;
        adouble[1] = d0 + d1 * (double) partialTicks;
        adouble[2] = this.ringBuffer[i][2] + (this.ringBuffer[j][2] - this.ringBuffer[i][2]) * (double) partialTicks;
        return adouble;
    }

    public Vec3d getHeadLookVec(float p_184665_1_) {
        IPhase iphase = getPhaseManager().getCurrentPhase();
        Vec3d vec3d;

        if (!iphase.getId().equals(PhaseRegistry.LANDING) && iphase.getId().equals(PhaseRegistry.TAKEOFF)) {
            if (iphase.getIsStationary()) {
                float f4 = this.rotationPitch;
                float f5 = 1.5F;
                this.rotationPitch = -45.0F;
                vec3d = this.getLook(p_184665_1_);
                this.rotationPitch = f4;
            } else {
                vec3d = this.getLook(p_184665_1_);
            }
        } else {
            BlockPos blockpos = getDragonGuardCenter();
            float f = Math.max(MathHelper.sqrt(this.getDistanceSqToCenter(blockpos)) / 4.0F, 1.0F);
            float f1 = 6.0F / f;
            float f2 = this.rotationPitch;
            float f3 = 1.5F;
            this.rotationPitch = -f1 * 1.5F * 5.0F;
            vec3d = this.getLook(p_184665_1_);
            this.rotationPitch = f2;
        }

        return vec3d;
    }

    @Override
    public int getMaxSpawnedInChunk() {
        return 1;
    }

    @Override
    protected boolean canDespawn() {
        return false;
    }

    @Override
    public void addTrackingPlayer(EntityPlayerMP player) {
        super.addTrackingPlayer(player);
        bossInfo.setColor(getBarColor());
        this.bossInfo.addPlayer(player);
    }

    @Override
    public void removeTrackingPlayer(EntityPlayerMP player) {
        super.removeTrackingPlayer(player);
        this.bossInfo.removePlayer(player);
    }

    public BossInfo.Color getBarColor() {
        return BossInfo.Color.BLUE;
    }

    @Override
    public boolean isNonBoss() {
        return false;
    }

    @Override
    public void attackEntityWithRangedAttack(EntityLivingBase target, float distanceFactor) {
        heads.forEach(x -> {
            double d14 = 1.0D;
            Vec3d vec3d2 = this.getLook(1.0F);
            double d6 = x.posX - vec3d2.x * 1.0D;
            double d7 = x.posY + (double) (x.height / 2.0F) + 0.5D;
            double d8 = x.posZ - vec3d2.z * 1.0D;
            double d9 = target.posX - d6;
            double d10 = target.posY + (double) (target.height / 2.0F) - (d7 + (double) (x.height / 2.0F));
            double d11 = target.posZ - d8;
            this.world.playEvent(null, 1017, new BlockPos(this), 0);
            this.world.spawnEntity(createFireball(d9, d10, d11, d6, d7, d8));
        });
    }

    @Override
    public void setSwingingArms(boolean swingingArms) {
        // ignored
    }

    @SideOnly(Side.CLIENT)
    public float getHeadPartYOffset(int p_184667_1_, double[] p_184667_2_, double[] p_184667_3_) {
        IPhase iphase = getPhaseManager().getCurrentPhase();
        double d0;

        if (!iphase.getId().equals(PhaseRegistry.LANDING) && !iphase.getId().equals(PhaseRegistry.TAKEOFF)) {
            if (iphase.getIsStationary()) {
                d0 = p_184667_1_;
            } else if (p_184667_1_ == 6) {
                d0 = 0.0D;
            } else {
                d0 = p_184667_3_[1] - p_184667_2_[1];
            }
        } else {
            BlockPos blockpos = this.getDragonGuardCenter();
            float f = Math.max(MathHelper.sqrt(this.getDistanceSqToCenter(blockpos)) / 4.0F, 1.0F);
            d0 = (float) p_184667_1_ / f;
        }

        return (float) d0;
    }

    /**
     * handles entity death timer, experience orb and particle creation
     */
    protected void onDeathUpdate() {
        ++this.deathTicks;

        if (this.deathTicks >= 180 && this.deathTicks <= 200) {
            float f = (this.rand.nextFloat() - 0.5F) * 8.0F;
            float f1 = (this.rand.nextFloat() - 0.5F) * 4.0F;
            float f2 = (this.rand.nextFloat() - 0.5F) * 8.0F;
            this.world.spawnParticle(EnumParticleTypes.EXPLOSION_HUGE, this.posX + (double) f, this.posY + 2.0D + (double) f1, this.posZ + (double) f2, 0.0D, 0.0D, 0.0D);
        }

        boolean flag = this.world.getGameRules().getBoolean("doMobLoot");
        int i = 500;

        if (!this.world.isRemote) {
            if (this.deathTicks == 1) {
                this.world.playBroadcastSound(1028, new BlockPos(this), 0);
            }
        }

        this.move(MoverType.SELF, 0.0D, 0.10000000149011612D, 0.0D);
        this.rotationYaw += 20.0F;
        this.renderYawOffset = this.rotationYaw;

        if (this.deathTicks == 200 && !this.world.isRemote) {
            this.setDead();
        }
    }

    /**
     * Simplifies the value of a number by adding/subtracting 180 to the point that the number is between -180 and 180.
     */
    protected float simplifyAngle(double p_70973_1_) {
        return (float) MathHelper.wrapDegrees(p_70973_1_);
    }

    protected Entity createFireball(double accelX, double accelY, double accelZ, double x, double y, double z) {
        EntityDragonFireball entitydragonfireball = new EntityDragonFireball(this.world, this, accelX, accelY, accelZ);
        entitydragonfireball.setLocationAndAngles(x, y, z, 0.0F, 0.0F);
        return entitydragonfireball;
    }

    /**
     * Returns all parts of dragon. Constructing veriable here, not really efficient
     *
     * @return
     */
    private Collection<MultiPartEntityPart> getAllParts() {
        ArrayList<MultiPartEntityPart> parts = new ArrayList<>(Arrays.asList(this.dragonPartNeck, this.dragonPartBody, this.dragonPartTail1, this.dragonPartTail2, this.dragonPartTail3, this.dragonPartWing1, this.dragonPartWing2));
        parts.addAll(heads);
        return parts;
    }

    /**
     * Attacks all entities inside this list, dealing 5 hearts of damage.
     */
    protected void attackEntitiesInList(List<Entity> entities) {
        for (int i = 0; i < entities.size(); ++i) {
            Entity entity = entities.get(i);

            if (entity instanceof EntityLivingBase) {
                attackEntityAsMob(entity);
            }
        }
    }

    /**
     * Performs attack to entity near the dragon
     *
     * @param entityIn
     */
    protected void attackFarEntityAsMob(EntityLivingBase entityIn) {
        entityIn.attackEntityFrom(DamageSource.causeMobDamage(this), (float) (getEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).getAttributeValue() / 2));
        this.applyEnchantments(this, entityIn);
    }

    @Override
    public boolean attackEntityAsMob(Entity entityIn) {
        if (super.attackEntityAsMob(entityIn)) {

            if (entityIn instanceof EntityLivingBase)
                performKnockBack(((EntityLivingBase) entityIn));

            return true;
        }

        return false;
    }

    /**
     * Pushes all entities inside the list away from the enderdragon.
     */
    private void collideWithEntities(List<Entity> list) {
        for (Entity entity : list) {
            if (entity instanceof EntityLivingBase) {
                performKnockBack(((EntityLivingBase) entity));

                if (!getPhaseManager().getCurrentPhase().getIsStationary() && ((EntityLivingBase) entity).getRevengeTimer() < entity.ticksExisted - 2) {
                    attackFarEntityAsMob(((EntityLivingBase) entity));
                }
            }
        }
    }

    private void performKnockBack(EntityLivingBase entity) {
        double d0 = (this.dragonPartBody.getEntityBoundingBox().minX + this.dragonPartBody.getEntityBoundingBox().maxX) / 2.0D;
        double d1 = (this.dragonPartBody.getEntityBoundingBox().minZ + this.dragonPartBody.getEntityBoundingBox().maxZ) / 2.0D;
        double d2 = entity.posX - d0;
        double d3 = entity.posZ - d1;
        double d4 = d2 * d2 + d3 * d3;

        entity.knockBack(this, knockback, d2 / d4 * 4.0D, d3 / d4 * 4.0D);
    }

    private float getHeadYOffset() {
        double d0;

        if (this.phaseManager.getCurrentPhase().getIsStationary()) {
            d0 = -1.0D;
        } else {
            double[] adouble = this.getMovementOffsets(5, 1.0F);
            double[] adouble1 = this.getMovementOffsets(0, 1.0F);
            d0 = adouble[1] - adouble1[1];
        }

        return (float) d0;
    }

    // regiond NBT

    @Override
    public NBTTagCompound writeToNBT(NBTTagCompound compound) {
        NBTTagCompound nbt = super.writeToNBT(compound);
        nbt.setString("DragonPhase", getPhaseManager().getCurrentPhase().getId().toString());
        return nbt;
    }

    @Override
    public void readFromNBT(NBTTagCompound compound) {
        super.readFromNBT(compound);

        if (compound.hasKey("DragonPhase")) {
            getPhaseManager().setPhase(new ResourceLocation(compound.getString("DragonPhase")));
        }
    }

    // endregion
}
